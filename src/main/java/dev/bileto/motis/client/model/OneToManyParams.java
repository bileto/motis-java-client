/*
 * MOTIS API
 * This is the MOTIS routing API.  Overview of MOTIS API versions:  MOTIS 0.x - deprecated/discontinued  MOTIS 2.x - current, providing:  * /api/v5/{plan,trip,stoptimes,map/trips} renamed METRO mode to SUBURBAN, AREAL_LIFT to AERIAL_LIFT; since MOTIS 2.5.0 * /api/v4/{plan,trip,stoptimes,map/trips} new displayName property, routeShortName only contains actual route short name from source; since MOTIS 2.2.0 * /api/v3/plan with correct maxTransfers API parameter (transfers actually corresponding to number of changes between transit legs (and not to number of transit legs), i.e. maxTransfers=0 returns direct public transit connections, as expected); since MOTIS 2.0.84  * /api/v2/{plan,trip} returns Google polylines with precision=6; since MOTIS 2.0.60 * /api/v1/{plan,trip} returns Google polylines with precision=7 (not defined for |longitude|>107) * /api/v1/_* all other endpoints  If you use the JS client lib https://www.npmjs.com/package/@motis-project/motis-client, endpoint versions will be taken into account automatically (i.e. the newest one available will be used). 
 *
 * The version of the OpenAPI document: v5
 * Contact: felix@triptix.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package dev.bileto.motis.client.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import dev.bileto.motis.client.model.ElevationCosts;
import dev.bileto.motis.client.model.Mode;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * OneToManyParams
 */
@JsonPropertyOrder({
  OneToManyParams.JSON_PROPERTY_ONE,
  OneToManyParams.JSON_PROPERTY_MANY,
  OneToManyParams.JSON_PROPERTY_MODE,
  OneToManyParams.JSON_PROPERTY_MAX,
  OneToManyParams.JSON_PROPERTY_MAX_MATCHING_DISTANCE,
  OneToManyParams.JSON_PROPERTY_ELEVATION_COSTS,
  OneToManyParams.JSON_PROPERTY_ARRIVE_BY
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
public class OneToManyParams {
  public static final String JSON_PROPERTY_ONE = "one";
  @jakarta.annotation.Nonnull
  private String one;

  public static final String JSON_PROPERTY_MANY = "many";
  @jakarta.annotation.Nonnull
  private List<String> many = new ArrayList<>();

  public static final String JSON_PROPERTY_MODE = "mode";
  @jakarta.annotation.Nonnull
  private Mode mode;

  public static final String JSON_PROPERTY_MAX = "max";
  @jakarta.annotation.Nonnull
  private BigDecimal max;

  public static final String JSON_PROPERTY_MAX_MATCHING_DISTANCE = "maxMatchingDistance";
  @jakarta.annotation.Nonnull
  private BigDecimal maxMatchingDistance;

  public static final String JSON_PROPERTY_ELEVATION_COSTS = "elevationCosts";
  @jakarta.annotation.Nonnull
  private ElevationCosts elevationCosts;

  public static final String JSON_PROPERTY_ARRIVE_BY = "arriveBy";
  @jakarta.annotation.Nonnull
  private Boolean arriveBy;

  public OneToManyParams() {
  }

  public OneToManyParams one(@jakarta.annotation.Nonnull String one) {
    
    this.one = one;
    return this;
  }

  /**
   * geo location as latitude;longitude
   * @return one
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(value = JSON_PROPERTY_ONE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getOne() {
    return one;
  }


  @JsonProperty(value = JSON_PROPERTY_ONE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setOne(@jakarta.annotation.Nonnull String one) {
    this.one = one;
  }

  public OneToManyParams many(@jakarta.annotation.Nonnull List<String> many) {
    
    this.many = many;
    return this;
  }

  public OneToManyParams addManyItem(String manyItem) {
    if (this.many == null) {
      this.many = new ArrayList<>();
    }
    this.many.add(manyItem);
    return this;
  }

  /**
   * geo locations as latitude;longitude,latitude;longitude,...
   * @return many
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(value = JSON_PROPERTY_MANY, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<String> getMany() {
    return many;
  }


  @JsonProperty(value = JSON_PROPERTY_MANY, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMany(@jakarta.annotation.Nonnull List<String> many) {
    this.many = many;
  }

  public OneToManyParams mode(@jakarta.annotation.Nonnull Mode mode) {
    
    this.mode = mode;
    return this;
  }

  /**
   * routing profile to use (currently supported: \\&#x60;WALK\\&#x60;, \\&#x60;BIKE\\&#x60;, \\&#x60;CAR\\&#x60;) 
   * @return mode
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(value = JSON_PROPERTY_MODE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Mode getMode() {
    return mode;
  }


  @JsonProperty(value = JSON_PROPERTY_MODE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMode(@jakarta.annotation.Nonnull Mode mode) {
    this.mode = mode;
  }

  public OneToManyParams max(@jakarta.annotation.Nonnull BigDecimal max) {
    
    this.max = max;
    return this;
  }

  /**
   * maximum travel time in seconds
   * @return max
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(value = JSON_PROPERTY_MAX, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public BigDecimal getMax() {
    return max;
  }


  @JsonProperty(value = JSON_PROPERTY_MAX, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMax(@jakarta.annotation.Nonnull BigDecimal max) {
    this.max = max;
  }

  public OneToManyParams maxMatchingDistance(@jakarta.annotation.Nonnull BigDecimal maxMatchingDistance) {
    
    this.maxMatchingDistance = maxMatchingDistance;
    return this;
  }

  /**
   * maximum matching distance in meters to match geo coordinates to the street network
   * @return maxMatchingDistance
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(value = JSON_PROPERTY_MAX_MATCHING_DISTANCE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public BigDecimal getMaxMatchingDistance() {
    return maxMatchingDistance;
  }


  @JsonProperty(value = JSON_PROPERTY_MAX_MATCHING_DISTANCE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMaxMatchingDistance(@jakarta.annotation.Nonnull BigDecimal maxMatchingDistance) {
    this.maxMatchingDistance = maxMatchingDistance;
  }

  public OneToManyParams elevationCosts(@jakarta.annotation.Nonnull ElevationCosts elevationCosts) {
    
    this.elevationCosts = elevationCosts;
    return this;
  }

  /**
   * Optional. Default is &#x60;NONE&#x60;.  Set an elevation cost profile, to penalize routes with incline. - &#x60;NONE&#x60;: No additional costs for elevations. This is the default behavior - &#x60;LOW&#x60;: Add a low cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if small detours are required. - &#x60;HIGH&#x60;: Add a high cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if larger detours are required.  As using an elevation costs profile will increase the travel duration, routing through steep terrain may exceed the maximal allowed duration, causing a location to appear unreachable. Increasing the maximum travel time for these segments may resolve this issue.  Elevation cost profiles are currently used by following street modes: - &#x60;BIKE&#x60; 
   * @return elevationCosts
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(value = JSON_PROPERTY_ELEVATION_COSTS, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public ElevationCosts getElevationCosts() {
    return elevationCosts;
  }


  @JsonProperty(value = JSON_PROPERTY_ELEVATION_COSTS, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setElevationCosts(@jakarta.annotation.Nonnull ElevationCosts elevationCosts) {
    this.elevationCosts = elevationCosts;
  }

  public OneToManyParams arriveBy(@jakarta.annotation.Nonnull Boolean arriveBy) {
    
    this.arriveBy = arriveBy;
    return this;
  }

  /**
   * true &#x3D; many to one false &#x3D; one to many 
   * @return arriveBy
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(value = JSON_PROPERTY_ARRIVE_BY, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getArriveBy() {
    return arriveBy;
  }


  @JsonProperty(value = JSON_PROPERTY_ARRIVE_BY, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setArriveBy(@jakarta.annotation.Nonnull Boolean arriveBy) {
    this.arriveBy = arriveBy;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OneToManyParams oneToManyParams = (OneToManyParams) o;
    return Objects.equals(this.one, oneToManyParams.one) &&
        Objects.equals(this.many, oneToManyParams.many) &&
        Objects.equals(this.mode, oneToManyParams.mode) &&
        Objects.equals(this.max, oneToManyParams.max) &&
        Objects.equals(this.maxMatchingDistance, oneToManyParams.maxMatchingDistance) &&
        Objects.equals(this.elevationCosts, oneToManyParams.elevationCosts) &&
        Objects.equals(this.arriveBy, oneToManyParams.arriveBy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(one, many, mode, max, maxMatchingDistance, elevationCosts, arriveBy);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OneToManyParams {\n");
    sb.append("    one: ").append(toIndentedString(one)).append("\n");
    sb.append("    many: ").append(toIndentedString(many)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    max: ").append(toIndentedString(max)).append("\n");
    sb.append("    maxMatchingDistance: ").append(toIndentedString(maxMatchingDistance)).append("\n");
    sb.append("    elevationCosts: ").append(toIndentedString(elevationCosts)).append("\n");
    sb.append("    arriveBy: ").append(toIndentedString(arriveBy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

